from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import Dict, List, Optional
import json
from datetime import datetime

from pydantic import BaseModel
from app.infra.db import get_db
from app.models.room import Room, RoomMember
from app.models.stt import RoomSttResult
from app.translation.openai_service import openai_service
from app.core.logging import get_logger

logger = get_logger(__name__)
router = APIRouter(prefix="/summary", tags=["summary"])

# ============ Schemas ============

class SummarizationContent(BaseModel):
    main_point: str
    task: str
    decided: str

class SummarizationData(BaseModel):
    summarization: SummarizationContent
    meeting_date: str
    past_time: str
    meeting_member: int
    message_count: int

class SummarizationResponse(BaseModel):
    summary: SummarizationData

# ============ Endpoints ============

@router.post("/summarization/{room_id}", response_model=SummarizationResponse)
async def get_summarization(
    room_id: str,
    db: AsyncSession = Depends(get_db)
):
    """
    会議の要約（メインポイント、タスク、決定事項）を取得します。
    RoomSttResultテーブルから音声文字起こし（STT）データのみを使用して、
    OpenAI を使用して要約を生成します。
    """
    try:
        logger.info(f"Generating summary for room {room_id}")
        
        # 1. Fetch room info
        room_stmt = select(Room).where(Room.id == room_id)
        room_result = await db.execute(room_stmt)
        room = room_result.scalar_one_or_none()
        
        if not room:
            logger.warning(f"Room {room_id} not found")
            raise HTTPException(status_code=404, detail="Meeting room not found")
        
        # 2. Fetch member info
        member_stmt = select(RoomMember).where(RoomMember.room_id == room_id)
        member_result = await db.execute(member_stmt)
        members = member_result.scalars().all()
        member_count = len(members)
        participant_names = [m.display_name for m in members]
        member_map = {m.id: m.display_name for m in members}
        
        logger.info(f"Room {room_id} has {member_count} members")
        
        # 3. STT（音声文字起こし）データを取得
        stt_stmt = select(RoomSttResult).where(
            RoomSttResult.room_id == room_id
        ).order_by(RoomSttResult.seq.asc())  # シーケンス番号で時系列順
        
        stt_result = await db.execute(stt_stmt)
        stt_messages = stt_result.scalars().all()
        
        logger.debug(f"Fetched {len(stt_messages)} STT messages")
        
        # 4. STTメッセージが存在するかチェック
        total_messages = len(stt_messages)
        if total_messages == 0:
            logger.warning(f"No STT messages found for room {room_id}")
            return SummarizationResponse(
                summary=SummarizationData(
                    summarization=SummarizationContent(
                        main_point="No voice recordings in this meeting",
                        task="N/A",
                        decided="N/A"
                    ),
                    meeting_date=room.created_at.strftime("%Y-%m-%d"),
                    past_time="Unknown",
                    meeting_member=member_count,
                    message_count=0
                )
            )
        
        # 5. STTデータを時系列（シーケンス番号順）でフォーマット
        text_parts = ["=== VOICE TRANSCRIPT (Speech-to-Text) ==="]
        
        for msg in stt_messages:
            sender_name = member_map.get(msg.member_id, "Unknown")
            time_str = msg.created_at.strftime('%H:%M:%S')
            seq = msg.seq
            text_parts.append(f"[{time_str}] [{seq}] {sender_name}: {msg.stt_text}")
        
        conversation_text = "\n".join(text_parts)
        
        logger.debug(f"STT transcript length: {len(conversation_text)} characters")
        
        # 6. 音声文字起こし用のプロンプトを構築
        prompt = f"""
You are a professional meeting summarizer specializing in analyzing voice transcriptions from meetings.

The following is a transcript of a meeting generated by speech-to-text (STT) technology. 
The transcript is presented in chronological order with timestamps.

Note: As this is STT output, there may be:
- Minor transcription errors
- Informal spoken language
- Incomplete sentences or fillers (um, uh, etc.)

Your task is to analyze the conversation flow and extract meaningful information.

Voice Transcript:
{conversation_text}

Participants: {', '.join(participant_names)}

Please provide a comprehensive summary with:

1. **Main Points**: What were the key topics discussed during the meeting? Summarize the main ideas and important discussions in a clear, organized manner.

2. **Tasks/Action Items**: What specific actions or tasks were mentioned? Who is responsible for each task? Include any deadlines or timeframes mentioned.

3. **Decisions**: What key decisions were made? What agreements or conclusions were reached during the meeting?

Respond ONLY with valid JSON in this exact format:
{{
    "main_point": "Clear and comprehensive summary of the main discussion topics",
    "task": "List of action items with responsible persons and deadlines",
    "decided": "Key decisions and agreements made during the meeting"
}}
"""
        
        # 7. Call OpenAI
        logger.debug("Sending request to OpenAI API")
        
        response = openai_service.client.chat.completions.create(
            model=openai_service.model,
            messages=[
                {
                    "role": "system",
                    "content": "You are a professional meeting summarizer specializing in voice transcriptions. You provide comprehensive, concise summaries in valid JSON format, understanding the nuances of spoken language captured via speech-to-text."
                },
                {"role": "user", "content": prompt}
            ],
            response_format={"type": "json_object"},
            temperature=0.5,
        )
        
        result = json.loads(response.choices[0].message.content)
        
        # 9. Calculate duration
        if room.ended_at:
            duration = room.ended_at - room.created_at
            past_time = int(duration.total_seconds() / 60)
        else:
            past_time = 0
        past_time_str = f"{past_time} min" if past_time > 0 else "Unknown"
        
        meeting_date_str = room.created_at.strftime("%Y-%m-%d")
        
        logger.info(f"Summary generated successfully for room {room_id} with {total_messages} STT messages")
        
        return SummarizationResponse(
            summary=SummarizationData(
                summarization=SummarizationContent(
                    main_point=result.get("main_point", ""),
                    task=result.get("task", ""),
                    decided=result.get("decided", "")
                ),
                meeting_date=meeting_date_str,
                past_time=past_time_str,
                meeting_member=member_count,
                message_count=total_messages
            )
        )
    
    except HTTPException:
        raise
    except json.JSONDecodeError as e:
        logger.error(f"Error parsing OpenAI response as JSON: {e}")
        raise HTTPException(status_code=500, detail="Failed to parse summary response")
    except Exception as e:
        logger.error(f"Error getting summarization for room {room_id}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Internal server error")


